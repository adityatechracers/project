class CommunicationsController < ApplicationController
  before_filter :authenticate_user!
  load_and_authorize_resource
  skip_load_and_authorize_resource :only => [:index,:schedule,:modal]
  before_filter :check_mobile, :only => [:start,:start_form]

  def create
    @communication.user_id = current_user.id
    @communication.datetime ||= DateTime.now
    @communication.datetime_exact ||= true
    @communication.next_step ||= params[:next_step]
    respond_to do |format|
      if @communication.save
        format.html do
          raise "format html"
            post_create
        end
        format.json do
          render json: { template:render_to_string(
            partial: "shared/communication_table_row", formats:[:html], locals: {c:@communication}
          )}
        end
      else
        format.html do
          raise "new errror "
          render "new", :error => "Something went wrong"
        end
        format.json do
          render json: nil, status: :unprocessable_entity
        end
      end
    end
  rescue ActionController::RedirectBackError
    redirect_to leads_path, :notice => "Your communication has been added"
  end

  def index
    @communications = if params[:filter].nil?
      Communication.not_deleted.order("type DESC, datetime ASC")
    elsif params[:filter] == "planned"
      PlannedCommunication.not_deleted
    elsif params[:filter] == "records"
      CommunicationRecord.not_deleted.order("datetime DESC")
    else
      Communication.not_deleted
    end
    apply_date_range_filter :datetime
    @communications = @communications.where(:job_id => params[:job]) if params.has_key? :job
    @communications = @communications.includes(:job => :contact).page(params[:page] || 1)

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @communications.collect { |c| c.to_event } }
    end
  end

  def schedule

  end

  def show

  end

  def edit

  end

  def update
    comm_params = params[:planned_communication].present? ? params[:planned_communication] : params[:communication_record]
    comm_params[:user_id] = current_user.id
    comm_params[:datetime] ||= DateTime.now
    comm_params[:datetime_exact] ||= true
    comm_params[:next_step] = params[:next_step]
    if @communication.update_attributes comm_params
      case params[:next_step]
        when "dead_lead"
          @communication.job.update_attributes({:active => false})
        when "call_back_on"
          Communication.create({:datetime => params[:call_back_on_datetime], :job_id => @communication.job_id, :user_id => current_user.id, :action => "Call", :datetime_exact => true, :type => "PlannedCommunication", :note => "Automatically generated by the previous communication."})
        when "call_back_around"
          Communication.create({:datetime => params[:call_back_around_datetime], :job_id => @communication.job_id, :user_id => current_user.id, :action => "Call", :datetime_exact => false, :type => "PlannedCommunication", :note => "Automatically generated by the previous communication."})
        when "schedule_appointment"
          redirect_to appointments_path, :notice => "Your communication has been added"
          return
        when "schedule_job"
          redirect_to edit_job_path(@communication.job), :notice => "Your communication has been added"
          return
      end
      redirect_to :back, :notice => "Your communication has been updated"
    else
      render "edit", :error => "Something went wrong"
    end
  rescue ActionController::RedirectBackError
    redirect_to communications_path, :notice => "Your communication has been updated"
  end

  def destroy
    redirect_to communications_path, :notice => "Your communication has been deleted" if @communication.destroy
  end

  def start

  end

  def start_form
    render :partial => "start"
  end

  def start_new_form
    @job = Job.find params[:job_id]
    @communication = Communication.new(:job_id => @job.id, :user_id => current_user.id)
    render :partial => "start_modal"
  end

  def start_planned_form
    @communication = Communication.find(params[:id], :include => {:job => :contact})
    render :partial => "start_modal"
  end

  def plan_form
    @job = Job.find params[:job_id]
    @communication = Communication.new(:job_id => @job.id, :user_id => current_user.id)
    render :partial => "plan"
  end

  def modal
    @communication = params.has_key?(:id) ? Communication.find(params[:id], :include => {:job => :contact}) : Communication.new
    render :partial => 'modal_form'
  end

  private

  def post_create
    case params[:next_step]
      when "dead_lead"
        @communication.job.update_attributes({:active => false})
      when "call_back_on"
        Communication.create({:datetime => params[:call_back_on_datetime], :job_id => @communication.job_id, :user_id => current_user.id, :action => "Call", :datetime_exact => true, :type => "PlannedCommunication", :note => "Automatically generated by the previous communication."})
      when "call_back_around"
        Communication.create({:datetime => params[:call_back_around_datetime], :job_id => @communication.job_id, :user_id => current_user.id, :action => "Call", :datetime_exact => false, :type => "PlannedCommunication", :note => "Automatically generated by the previous communication."})
      when "schedule_appointment"
        redirect_to appointments_path, :notice => "Your communication has been added"
        return
      when "schedule_job"
        redirect_to edit_job_path(@communication.job), :notice => "Your communication has been added"
        return
    end
    redirect_to :back, :notice => "Your communication has been added"
  end

  def check_mobile
    @mobile = if session[:mobile_param]
      session[:mobile_param] == "1"
    else
      request.user_agent =~ /Mobile|webOS/
    end
  end
end
