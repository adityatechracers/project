class GoogleCalendarWrapper

  BASE_ID = 'corkcrmevent'.freeze
  DEFAULT_DESCRIPTION = 'This event was generated by CorkCRM.'.freeze

  def initialize(user)
    begin
      configure_client(user)
    rescue => e
      raise e
    end
  end


  def push_event(appointment, action, calendar_id='primary')
    case action
    when 'create'
      push_new_event(appointment, calendar_id)
    when 'update'
      push_existing_event(appointment, calendar_id)
    when 'delete'
      delete_event(appointment, calendar_id)
    end
  end

  def push_new_event(appointment, calendar_id)
    user_email = appointment.user.email
    event_id = generate_event_id(appointment)
    appointment_event = appointment.to_event

    event = {
      'id' => event_id,
      'summary' => appointment_event[:title],
      'description' => appointment.job_notes,
      'start' => { "dateTime" => appointment_event[:start].to_datetime.rfc3339 },
      'end' => { "dateTime" => appointment_event[:end].to_datetime.rfc3339 },
      'attendees' => [ { "email" =>  user_email} ]
    }

    sent_event = @client.execute(:api_method => @service.events.insert,
                            :parameters => {'calendarId' => calendar_id, 'sendNotifications' => false},
                            :body => JSON.dump(event),
                            :headers => {'Content-Type' => 'application/json'})
  end

  def push_existing_event(appointment, calendar_id)
    # look for the existing event on google calendar
    events_from_request = get_events(calendar_id)
    events = set_events(events_from_request)
    event_id = generate_event_id(appointment)
    existing_event = find_by_event_id(events, event_id)

    # if the event actually exists on google calendar, update it
    # otherwise, create it
    if existing_event.present?
      user_email = appointment.user.email
      appointment_event = appointment.to_event

      event = {
        'summary' => appointment_event[:title],
        'description' => appointment.job_notes,
        'start' => { "dateTime" => appointment_event[:start].to_datetime.rfc3339 },
        'end' => { "dateTime" => appointment_event[:end].to_datetime.rfc3339 },
        'attendees' => [ { "email" =>  user_email} ]
      }

      sent_event = @client.execute(:api_method => @service.events.update,
                              :parameters => {'calendarId' => calendar_id,
                                'eventId' => event_id,
                                'sendNotifications' => false},
                              :body => JSON.dump(event),
                              :headers => {'Content-Type' => 'application/json'})
    else
      push_new_event(appointment, calendar_id)
    end

  end

  def delete_event(appointment, calendar_id)
    # look for the existing event on google calendar
    events_from_request = get_events(calendar_id)
    events = set_events(events_from_request)
    event_id = generate_event_id(appointment)
    existing_event = find_by_event_id(events, event_id)

    # if the event actually exists on google calendar, delete it
    if existing_event.present?
      deleted_event = @client.execute(:api_method => @service.events.delete,
                              :parameters => {'calendarId' => calendar_id, 'eventId' => event_id},
                              :headers => {'Content-Type' => 'application/json'})
    end
  end

  def get_calendars
    calendars = @client.execute(
      :api_method => @service.calendar_list.list,
      :parameters => {},
      :headers => {'Content-Type' => 'application/json'}
    )
    JSON.parse(calendars.body)
  end


  def get_events(calendar_id)
    events = @client.execute(
      :api_method => @service.events.list,
      :parameters => {'calendarId' => calendar_id,
        'timeMin' => 30.days.ago.to_datetime.rfc3339,
        'timeMax' => 30.days.from_now.to_datetime.rfc3339,
        'timeZone' => 'UTC',
        'singleEvents' => true},
      :headers => {'Content-Type' => 'application/json'}
    )

    hash_events = JSON.parse(events.body)
    hash_events['calendar_id'] = calendar_id
    hash_events
  end

  def import_calendars
    hash_calendars = get_calendars
    calendars = set_calendars(hash_calendars)
    update_google_calendars(calendars)
  end


  def import_events(calendar_id)
    hash_events = get_events(calendar_id)
    events = set_events(hash_events)
    update_google_events(events, calendar_id)
  end


  def get_free_busy(calendar_id='primary')
    free_busy = @client.execute(
      :api_method => @service.freebusy.query,
      :body => JSON.dump({ :timeMin => DateTime.now - 1.month,
                  :timeMax => DateTime.now + 1.month,
                  :timeZone => @user.organization.time_zone,
                  :items => [calendar_id]
                }),
      :headers => {'Content-Type' => 'application/json'}
    )

    JSON.parse(free_busy.body)
  end


  private

  def configure_client(user)
    @exception = nil
    @user = user
    @client = Google::APIClient.new(:application_name => "corkcrm", :application_version => "1.0")
    @client.authorization.access_token = @user.google_auth_token
    @client.authorization.refresh_token = @user.google_auth_refresh_token
    @client.authorization.client_id = ENV['GOOGLE_CLIENT_ID']
    @client.authorization.client_secret = ENV['GOOGLE_CLIENT_SECRET']
    refresh_authorization_token
    @service = @client.discovered_api('calendar', 'v3')
  end

  def refresh_authorization_token
    begin
      @client.authorization.refresh!
    rescue Signet::AuthorizationError => exception
      @exception = exception
      raise exception
    end
  end

  def generate_event_id(appointment)
    BASE_ID + appointment.id.to_s
  end

  def generated_by_cork?(event_id)
    event_id.start_with?(BASE_ID)
  end

  def find_by_event_id(events, event_id)
    found_event = nil
    events.each do |e|
      found_event = e if e[:event_id] == event_id
    end
    found_event
  end

  def update_google_calendars(calendars)
    calendars_ids = calendars.collect { |c| c[:calendar_id] }
    google_calendars = GoogleCalendar.where(calendar_id: calendars_ids)

    #update calendars if they are different from what we have in database
    google_calendars.each do |calendar|
      calendar_from_request = calendars.collect{ |c| c if c[:calendar_id] == calendar.calendar_id}.compact.first
      calendar.update_attributes(calendar_from_request) unless calendar.identical?(GoogleCalendar.new(calendar_from_request))
    end

    # check if there are new calendars and, if so, save them in database
    remaining_calendars_ids = calendars_ids - google_calendars.pluck(:calendar_id)
    if remaining_calendars_ids.any?
      remaining_calendars = calendars.keep_if{ |c| c[:calendar_id].in? remaining_calendars_ids }
      remaining_calendars.each { |rc| GoogleCalendar.create(rc) }
    end

    # delete calendars from database if they are not in the request response anymore
    all_calendars = GoogleCalendar.where(user_id: calendars.first[:user_id])
    deleted_calendars_ids = all_calendars.pluck(:calendar_id) - calendars_ids
    if deleted_calendars_ids.any?
      GoogleCalendar.where(calendar_id: deleted_calendars_ids).destroy_all
    end

  end


  def update_google_events(events, calendar_id)
    # get events ids, except for events that were generated by corkcrm itself
    events_ids = events.collect { |e| e[:event_id] unless generated_by_cork?(e[:event_id])}.compact
    google_events = GoogleEvent.where(event_id: events_ids)

    # update events if they are different from what we have in database
    google_events.each do |event|
      event_from_request = events.collect{ |e| e if e[:event_id] == event.event_id}.compact.first
      event.update_attributes(event_from_request) unless event.identical?(GoogleEvent.new(event_from_request))
    end

    # check if there are new events and, if so, save them in database
    remaining_events_ids = events_ids - google_events.pluck(:event_id)
    if remaining_events_ids.any?
      remaining_events = events.keep_if{ |e| e[:event_id].in? remaining_events_ids }
      remaining_events.each { |re| GoogleEvent.create(re) }
    end

    # delete events from database if they are not in the request response anymore
    calendar = GoogleCalendar.find_by_calendar_id calendar_id
    if calendar.present?
      deleted_events_ids = calendar.google_events.pluck(:event_id) - events_ids
      if deleted_events_ids.any?
        GoogleEvent.where(event_id: deleted_events_ids).destroy_all
      end
    end

  end


  def set_events(events)
    google_events = []
    google_calendar = GoogleCalendar.find_by_calendar_id events["calendar_id"]
    google_calendar_id = google_calendar.id

    events['items'].each do |event|
      e_params = {}
      e_params[:title] = event["summary"] || nil
      e_params[:start_datetime] = event["start"] ? event["start"]["dateTime"] : nil
      e_params[:end_datetime] = event["end"] ? event["end"]["dateTime"] : nil
      e_params[:status] = event["status"] || nil
      e_params[:description] = event["description"]
      e_params[:event_id] = event["id"]
      e_params[:user_id] = @user.id
      e_params[:google_calendar_id] = google_calendar_id

      google_events << e_params
    end

    google_events
  end


  def set_calendars(calendars)
    google_calendars = []
    calendars['items'].each do |calendar|
      c_params = {}
      c_params[:calendar_id] = calendar["id"]
      c_params[:title] = calendar["summary"] || nil
      c_params[:time_zone] = calendar["timeZone"] || nil
      c_params[:access_role] = calendar["accessRole"] || nil
      c_params[:primary] = calendar["primary"] || false
      c_params[:user_id] = @user.id

      google_calendars << c_params
    end

    google_calendars
  end


end
